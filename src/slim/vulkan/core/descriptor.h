#pragma once

#include "./base.h"



namespace gpu {

    const u32 DESC_SET_INDEX_GLOBAL   = 0; // The index of the global descriptor set
    const u32 DESC_SET_INDEX_INSTANCE = 1; // The index of the instance descriptor set

    struct DescriptorSetConfig { // The configuration for a descriptor set
        VkDescriptorSetLayoutBinding bindings[VULKAN_SHADER_MAX_BINDINGS];
        u8 sampler_binding_index;
        u8 binding_count;
    };




    struct Shader {
        enum class Stage {
            VERTEX = 0x00000001,
            GEOMETRY = 0x00000002,
            FRAGMENT = 0x00000004,
            COMPUTE = 0x0000008
        };

        struct Attribute {
            enum class Type {
                FLOAT32 = 0U,
                FLOAT32_2 = 1U,
                FLOAT32_3 = 2U,
                FLOAT32_4 = 3U,
                MATRIX_4 = 4U,
                INT8 = 5U,
                UINT8 = 6U,
                INT16 = 7U,
                UINT16 = 8U,
                INT32 = 9U,
                UINT32 = 10U,
            };

            struct Config {
                Type type;
                u8 size;
                u8 name_length;
                char* name;
            };

            Type type;
            char* name;
            u32 size;
        };

        enum class Flags {
            NONE = 0x0,
            DEPTH_TEST = 0x1,
            DEPTH_WRITE = 0x2
        };

        struct StageConfig { // Configuration for a shader stage, such as vertex or fragment
            VkShaderStageFlagBits stage;
            char file_name[255];
        };

        struct VulkanShaderConfig { // Shader configuration generated by vulkan_shader_create()
            u8 stage_count; // The number of shader stages in this shader
            StageConfig stages[VULKAN_SHADER_MAX_STAGES];  // The configuration for every stage of this shader

            VkDescriptorPoolSize pool_sizes[2]; // An array of descriptor pool sizes
            DescriptorSetConfig descriptor_sets[2]; // Descriptor sets: [global, instance]
            u16 max_descriptor_set_count; // The max number of descriptor sets that can be allocated from this shader (Should be decently high)
            u8 descriptor_set_count; // # of descriptor sets configured for this shader (1 if only using global uniforms/samplers; otherwise 2)
            VkVertexInputAttributeDescription attributes[VULKAN_SHADER_MAX_ATTRIBUTES]; // Attribute descriptions for this shader
            //face_cull_mode cull_mode;
        };

        enum class Scope {
            Global,   // Updated once per frame
            Instance, // Updated "per-instance" of the shader
            Local     // Updated per-object
        };

        struct Uniform {
            enum class Type {
                FLOAT32 = 0U,
                FLOAT32_2 = 1U,
                FLOAT32_3 = 2U,
                FLOAT32_4 = 3U,
                INT8 = 4U,
                UINT8 = 5U,
                INT16 = 6U,
                UINT16 = 7U,
                INT32 = 8U,
                UINT32 = 9U,
                MATRIX_4 = 10U,
                SAMPLER = 11U,
                CUSTOM = 255U
            };

            struct Config {
                Uniform::Type type;
                Scope scope;
                u16 size;
                u32 location;
                u8 name_length;
                char* name;
            };


            Type type; // The type of uniform
            Scope scope; // The scope of the uniform

            u16 size; // The size of the uniform (0 for samplers)
            u16 index; // Index into the internal uniform array
            u8 set_index; // The index of the descriptor set the uniform belongs to (0=global, 1=instance, INVALID_ID=local)
            u64 offset; // The offset in bytes from the beginning of the uniform set (global/instance/local)
            u16 location; // The location to be used as a lookup (=index except for samplers)
            // used to lookup texture index within the internal array at the given scope (global/instance))
        };

        struct Config { // Configuration for a shader. Typically created and destroyed by the shader resource loader, and set to the properties found in a .shadercfg resource file.
            char* name;
            Attribute::Config* attributes;
            Uniform::Config* uniforms;
            u8 stage_count; // The number of stages present in the shader
            u8 uniform_count;
            u8 attribute_count;
            Stage* stages; // The collection of stages
            char** stage_names; // The collection of stage names. Must align with stages array
            char** stage_filenames; // The collection of stage file names to be loaded (one per stage). Must align with stages array

            bool depth_test; // Indicates if depth testing should be done. */
            bool depth_write; // Indicates if the results of depth testing should be written to the depth buffer.
            // NOTE: This is ignored if depth_test is false.
        };

        u32 id;
        char* name;

        u32 flags;
        Scope bound_scope;

        // The amount of bytes that are required for UBO alignment.
        // This is used along with the UBO size to determine the ultimate stride, which is how much the UBOs are spaced out in the buffer.
        // For example, a required alignment of 256 means that the stride must be a multiple of 256 (true for some nVidia cards)
        u64 required_ubo_alignment;
        u64 global_ubo_size; // The actual size of the global uniform buffer object
        u64 global_ubo_stride; // The stride of the global uniform buffer object
        u64 global_ubo_offset; // The offset in bytes for the global UBO from the beginning of the uniform buffer
        u64 ubo_size; // The actual size of the instance uniform buffer object
        u64 ubo_stride; // Stride of the instance uniform buffer object
        u64 push_constant_size;   // Total size of all push constant ranges combined
        u64 push_constant_stride; // Push constant stride, aligned to 4 bytes as required by Vulkan
        // texture_map** global_texture_maps; // An array of global texture map pointers
        u8 instance_texture_count; // The number of instance textures
        u32 bound_instance_id; // The identifier of the currently bound instance
        u32 bound_ubo_offset; // The currently bound instance's ubo offset
        void* hashtable_block;  // The block of memory used by the uniform hashtable
        // hashtable uniform_lookup; // A hashtable to store uniform index/locations by name

        Uniform* uniforms; // An array of uniforms in this shader
        Attribute* attributes; // An array of attributes
        State state; // The internal state of the shader
        u8 push_constant_range_count; // The number of push constant ranges
        Range push_constant_ranges[32]; // An array of push constant ranges
        u16 attribute_stride; // The size of all attributes combined, a.k.a. the size of a vertex
        u64 render_frame_number; // Used to ensure the shader's globals are only updated once per frame

            /** @brief The block of memory mapped to the uniform buffer. */
            void* mapped_uniform_buffer_block;

            /** @brief The shader identifier. */
            u32 id;

            /** @brief The configuration of the shader generated by vulkan_create_shader(). */
            vulkan_shader_config config;

            /** @brief A pointer to the renderpass to be used with this shader. */
            vulkan_renderpass* renderpass;

            /** @brief An array of stages (such as vertex and fragment) for this shader. Count is located in config.*/
            vulkan_shader_stage stages[VULKAN_SHADER_MAX_STAGES];

            VkDescriptorPool descriptor_pool; // The descriptor pool used for this shader
            VkDescriptorSetLayout descriptor_set_layouts[2]; // Descriptor set layouts, max of 2. Index 0=global, 1=instance
            VkDescriptorSet global_descriptor_sets[3]; // Global descriptor sets, one per frame
            renderbuffer uniform_buffer; // The uniform buffer used by this shader
            GraphicsPipeline pipeline;

            /** @brief The instance states for all instances. @todo TODO: make dynamic */
            u32 instance_count;
            vulkan_shader_instance_state instance_states[VULKAN_MAX_MATERIAL_COUNT];

            /** @brief The number of global non-sampler uniforms. */
            u8 global_uniform_count;
            u8 global_uniform_sampler_count;
            u8 instance_uniform_count;
            u8 instance_uniform_sampler_count;
            u8 local_uniform_count;

        bool create(VulkanShaderConfig &config, RenderPass &renderpass, u8 stage_count, const char** stage_filenames, Stage stages[VULKAN_SHADER_MAX_STAGES]) {
            // TODO: configurable max descriptor allocate count.
            u32 max_descriptor_allocate_count = 1024;

            // Translate stages
            VkShaderStageFlags vk_stages[VULKAN_SHADER_MAX_STAGES];
            for (u8 i = 0; i < stage_count; ++i) {
                switch (stages[i]) {
                    case Stage::FRAGMENT:
                        vk_stages[i] = VK_SHADER_STAGE_FRAGMENT_BIT;
                        break;
                    case Stage::VERTEX:
                        vk_stages[i] = VK_SHADER_STAGE_VERTEX_BIT;
                        break;
                }
            }

            // TODO: configurable max descriptor allocate count.

            u32 max_descriptor_allocate_count = 1024;

            // Take a copy of the pointer to the context->
            vulkan_shader* internal_shader = (vulkan_shader*)s->internal_data;

            internal_shader->renderpass = pass->internal_data;

            // Build out the configuration.
            internal_shader->config.max_descriptor_set_count = max_descriptor_allocate_count;

            // Shader stages. Parse out the flags.
            kzero_memory(internal_shader->config.stages, sizeof(vulkan_shader_stage_config) * VULKAN_SHADER_MAX_STAGES);
            internal_shader->config.stage_count = 0;
            // Iterate provided stages.
            for (u32 i = 0; i < stage_count; i++) {
                // Make sure there is room enough to add the stage.
                if (internal_shader->config.stage_count + 1 > VULKAN_SHADER_MAX_STAGES) {
                    KERROR("Shaders may have a maximum of %d stages", VULKAN_SHADER_MAX_STAGES);
                    return false;
                }

                // Make sure the stage is a supported one.
                VkShaderStageFlagBits stage_flag;
                switch (stages[i]) {
                    case SHADER_STAGE_VERTEX:
                        stage_flag = VK_SHADER_STAGE_VERTEX_BIT;
                        break;
                    case SHADER_STAGE_FRAGMENT:
                        stage_flag = VK_SHADER_STAGE_FRAGMENT_BIT;
                        break;
                    default:
                        // Go to the next type.
                        KERROR("vulkan_shader_create: Unsupported shader stage flagged: %d. Stage ignored.", stages[i]);
                        continue;
                }

                // Set the stage and bump the counter.
                internal_shader->config.stages[internal_shader->config.stage_count].stage = stage_flag;
                string_ncopy(internal_shader->config.stages[internal_shader->config.stage_count].file_name, stage_filenames[i], 255);
                internal_shader->config.stage_count++;
            }

            // Zero out arrays and counts.
            kzero_memory(internal_shader->config.descriptor_sets, sizeof(vulkan_descriptor_set_config) * 2);
            internal_shader->config.descriptor_sets[0].sampler_binding_index = INVALID_ID_U8;
            internal_shader->config.descriptor_sets[1].sampler_binding_index = INVALID_ID_U8;

            // Attributes array.
            kzero_memory(internal_shader->config.attributes, sizeof(VkVertexInputAttributeDescription) * VULKAN_SHADER_MAX_ATTRIBUTES);

            // Get the uniform counts.
            internal_shader->global_uniform_count = 0;
            internal_shader->global_uniform_sampler_count = 0;
            internal_shader->instance_uniform_count = 0;
            internal_shader->instance_uniform_sampler_count = 0;
            internal_shader->local_uniform_count = 0;
            u32 total_count = darray_length(config->uniforms);
            for (u32 i = 0; i < total_count; ++i) {
                switch (config->uniforms[i].scope) {
                    case SHADER_SCOPE_GLOBAL:
                        if (config->uniforms[i].type == SHADER_UNIFORM_TYPE_SAMPLER) {
                            internal_shader->global_uniform_sampler_count++;
                        } else {
                            internal_shader->global_uniform_count++;
                        }
                        break;
                    case SHADER_SCOPE_INSTANCE:
                        if (config->uniforms[i].type == SHADER_UNIFORM_TYPE_SAMPLER) {
                            internal_shader->instance_uniform_sampler_count++;
                        } else {
                            internal_shader->instance_uniform_count++;
                        }
                        break;
                    case SHADER_SCOPE_LOCAL:
                        internal_shader->local_uniform_count++;
                        break;
                }
            }

            // For now, shaders will only ever have these 2 types of descriptor pools.
            internal_shader->config.pool_sizes[0] = (VkDescriptorPoolSize){VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1024};          // HACK: max number of ubo descriptor sets.
            internal_shader->config.pool_sizes[1] = (VkDescriptorPoolSize){VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 4096};  // HACK: max number of image sampler descriptor sets.

            // Global descriptor set config.
            if (internal_shader->global_uniform_count > 0 || internal_shader->global_uniform_sampler_count > 0) {
                // Global descriptor set config.
                vulkan_descriptor_set_config* set_config = &internal_shader->config.descriptor_sets[internal_shader->config.descriptor_set_count];

                // Global UBO binding is first, if present.
                if (internal_shader->global_uniform_count > 0) {
                    u8 binding_index = set_config->binding_count;
                    set_config->bindings[binding_index].binding = binding_index;
                    set_config->bindings[binding_index].descriptorCount = 1;
                    set_config->bindings[binding_index].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
                    set_config->bindings[binding_index].stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
                    set_config->binding_count++;
                }

                // Add a binding for Samplers if used.
                if (internal_shader->global_uniform_sampler_count > 0) {
                    u8 binding_index = set_config->binding_count;
                    set_config->bindings[binding_index].binding = binding_index;
                    set_config->bindings[binding_index].descriptorCount = internal_shader->global_uniform_sampler_count;  // One descriptor per sampler.
                    set_config->bindings[binding_index].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                    set_config->bindings[binding_index].stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
                    set_config->sampler_binding_index = binding_index;
                    set_config->binding_count++;
                }

                // Increment the set counter.
                internal_shader->config.descriptor_set_count++;
            }

            // If using instance uniforms, add a UBO descriptor set.
            if (internal_shader->instance_uniform_count > 0 || internal_shader->instance_uniform_sampler_count > 0) {
                // In that set, add a binding for UBO if used.
                vulkan_descriptor_set_config* set_config = &internal_shader->config.descriptor_sets[internal_shader->config.descriptor_set_count];

                if (internal_shader->instance_uniform_count > 0) {
                    u8 binding_index = set_config->binding_count;
                    set_config->bindings[binding_index].binding = binding_index;
                    set_config->bindings[binding_index].descriptorCount = 1;
                    set_config->bindings[binding_index].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
                    set_config->bindings[binding_index].stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
                    set_config->binding_count++;
                }

                // Add a binding for Samplers if used.
                if (internal_shader->instance_uniform_sampler_count > 0) {
                    u8 binding_index = set_config->binding_count;
                    set_config->bindings[binding_index].binding = binding_index;
                    set_config->bindings[binding_index].descriptorCount = internal_shader->instance_uniform_sampler_count;  // One descriptor per sampler.
                    set_config->bindings[binding_index].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
                    set_config->bindings[binding_index].stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;
                    set_config->sampler_binding_index = binding_index;
                    set_config->binding_count++;
                }

                // Increment the set counter.
                internal_shader->config.descriptor_set_count++;
            }

            // Invalidate all instance states.
            for (u32 i = 0; i < 1024; ++i) {
                internal_shader->instance_states[i].id = INVALID_ID;
            }

            // Keep a copy of the cull mode.
            internal_shader->config.cull_mode = config->cull_mode;

            return true;
        }
    };
}


void vulkan_renderer_shader_destroy(renderer_plugin* plugin, shader* s) {
    vulkan_context* context = (vulkan_context*)plugin->internal_context;
    if (s && s->internal_data) {
        vulkan_shader* shader = s->internal_data;
        if (!shader) {
            KERROR("vulkan_renderer_shader_destroy requires a valid pointer to a shader.");
            return;
        }

        VkDevice logical_device = context->device.logical_device;
        VkAllocationCallbacks* vk_allocator = context->allocator;

        // Descriptor set layouts.
        for (u32 i = 0; i < shader->config.descriptor_set_count; ++i) {
            if (shader->descriptor_set_layouts[i]) {
                vkDestroyDescriptorSetLayout(logical_device, shader->descriptor_set_layouts[i], vk_allocator);
                shader->descriptor_set_layouts[i] = 0;
            }
        }

        // Descriptor pool
        if (shader->descriptor_pool) {
            vkDestroyDescriptorPool(logical_device, shader->descriptor_pool, vk_allocator);
        }

        // Uniform buffer.
        vulkan_buffer_unmap_memory(plugin, &shader->uniform_buffer, 0, VK_WHOLE_SIZE);
        shader->mapped_uniform_buffer_block = 0;
        renderer_renderbuffer_destroy(&shader->uniform_buffer);

        // Pipeline
        vulkan_pipeline_destroy(context, &shader->pipeline);

        // Shader modules
        for (u32 i = 0; i < shader->config.stage_count; ++i) {
            vkDestroyShaderModule(context->device.logical_device, shader->stages[i].handle, context->allocator);
        }

        // Destroy the configuration.
        kzero_memory(&shader->config, sizeof(vulkan_shader_config));

        // Free the internal data memory.
        kfree(s->internal_data, sizeof(vulkan_shader), MEMORY_TAG_RENDERER);
        s->internal_data = 0;
    }
}

b8 vulkan_renderer_shader_initialize(renderer_plugin* plugin, shader* s) {
    vulkan_context* context = (vulkan_context*)plugin->internal_context;
    VkDevice logical_device = context->device.logical_device;
    VkAllocationCallbacks* vk_allocator = context->allocator;
    vulkan_shader* internal_shader = (vulkan_shader*)s->internal_data;

    // Create a module for each stage.
    kzero_memory(stages, sizeof(vulkan_shader_stage) * VULKAN_SHADER_MAX_STAGES);
    for (u32 i = 0; i < config.stage_count; ++i) {
        if (!create_shader_module(context, internal_shader, config.stages[i], &stages[i])) {
            KERROR("Unable to create %s shader module for '%s'. Shader will be destroyed.", config.stages[i].file_name, s->name);
            return false;
        }
    }

    // Static lookup table for our types->Vulkan ones.
    static VkFormat* types = 0;
    static VkFormat t[11];
    if (!types) {
        t[SHADER_ATTRIB_TYPE_FLOAT32] = VK_FORMAT_R32_SFLOAT;
        t[SHADER_ATTRIB_TYPE_FLOAT32_2] = VK_FORMAT_R32G32_SFLOAT;
        t[SHADER_ATTRIB_TYPE_FLOAT32_3] = VK_FORMAT_R32G32B32_SFLOAT;
        t[SHADER_ATTRIB_TYPE_FLOAT32_4] = VK_FORMAT_R32G32B32A32_SFLOAT;
        t[SHADER_ATTRIB_TYPE_INT8] = VK_FORMAT_R8_SINT;
        t[SHADER_ATTRIB_TYPE_UINT8] = VK_FORMAT_R8_UINT;
        t[SHADER_ATTRIB_TYPE_INT16] = VK_FORMAT_R16_SINT;
        t[SHADER_ATTRIB_TYPE_UINT16] = VK_FORMAT_R16_UINT;
        t[SHADER_ATTRIB_TYPE_INT32] = VK_FORMAT_R32_SINT;
        t[SHADER_ATTRIB_TYPE_UINT32] = VK_FORMAT_R32_UINT;
        types = t;
    }

    // Process attributes
    u32 attribute_count = darray_length(s->attributes);
    u32 offset = 0;
    for (u32 i = 0; i < attribute_count; ++i) {
        // Setup the new attribute.
        VkVertexInputAttributeDescription attribute;
        attribute.location = i;
        attribute.binding = 0;
        attribute.offset = offset;
        attribute.format = types[s->attributes[i].type];

        // Push into the config's attribute collection and add to the stride.
        config.attributes[i] = attribute;

        offset += s->attributes[i].size;
    }

    // Descriptor pool.
    VkDescriptorPoolCreateInfo pool_info = {VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO};
    pool_info.poolSizeCount = 2;
    pool_info.pPoolSizes = config.pool_sizes;
    pool_info.maxSets = config.max_descriptor_set_count;
    pool_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;

    // Create descriptor pool.
    VkResult result = vkCreateDescriptorPool(logical_device, &pool_info, vk_allocator, &descriptor_pool);
    if (!vulkan_result_is_success(result)) {
        KERROR("vulkan_shader_initialize failed creating descriptor pool: '%s'", vulkan_result_string(result, true));
        return false;
    }

    // Create descriptor set layouts.
    kzero_memory(descriptor_set_layouts, config.descriptor_set_count);
    for (u32 i = 0; i < config.descriptor_set_count; ++i) {
        VkDescriptorSetLayoutCreateInfo layout_info = {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO};
        layout_info.bindingCount = config.descriptor_sets[i].binding_count;
        layout_info.pBindings = config.descriptor_sets[i].bindings;
        result = vkCreateDescriptorSetLayout(logical_device, &layout_info, vk_allocator, &descriptor_set_layouts[i]);
        if (!vulkan_result_is_success(result)) {
            KERROR("vulkan_shader_initialize failed creating descriptor pool: '%s'", vulkan_result_string(result, true));
            return false;
        }
    }

    // TODO: This feels wrong to have these here, at least in this fashion. Should probably
    // Be configured to pull from someplace instead.
    // Viewport.
    VkViewport viewport;
    viewport.x = 0.0f;
    viewport.y = (f32)context->framebuffer_height;
    viewport.width = (f32)context->framebuffer_width;
    viewport.height = -(f32)context->framebuffer_height;
    viewport.minDepth = 0.0f;
    viewport.maxDepth = 1.0f;

    // Scissor
    VkRect2D scissor;
    scissor.offset.x = scissor.offset.y = 0;
    scissor.extent.width = context->framebuffer_width;
    scissor.extent.height = context->framebuffer_height;

    VkPipelineShaderStageCreateInfo stage_create_infos[VULKAN_SHADER_MAX_STAGES];
    kzero_memory(stage_create_infos, sizeof(VkPipelineShaderStageCreateInfo) * VULKAN_SHADER_MAX_STAGES);
    for (u32 i = 0; i < config.stage_count; ++i) {
        stage_create_infos[i] = stages[i].shader_stage_create_info;
    }

    vulkan_pipeline_config pipeline_config = {0};
    pipeline_config.renderpass = renderpass;
    pipeline_config.stride = s->attribute_stride;
    pipeline_config.attribute_count = darray_length(s->attributes);
    pipeline_config.attributes = config.attributes;  // shader->attributes,
    pipeline_config.descriptor_set_layout_count = config.descriptor_set_count;
    pipeline_config.descriptor_set_layouts = descriptor_set_layouts;
    pipeline_config.stage_count = config.stage_count;
    pipeline_config.stages = stage_create_infos;
    pipeline_config.viewport = viewport;
    pipeline_config.scissor = scissor;
    pipeline_config.cull_mode = config.cull_mode;
    pipeline_config.is_wireframe = false;
    pipeline_config.shader_flags = s->flags;
    pipeline_config.push_constant_range_count = s->push_constant_range_count;
    pipeline_config.push_constant_ranges = s->push_constant_ranges;

    b8 pipeline_result = vulkan_graphics_pipeline_create(context, &pipeline_config, &pipeline);

    if (!pipeline_result) {
        KERROR("Failed to load graphics pipeline for object shader.");
        return false;
    }

    // Grab the UBO alignment requirement from the device.
    s->required_ubo_alignment = context->device.properties.limits.minUniformBufferOffsetAlignment;

    // Make sure the UBO is aligned according to device requirements.
    s->global_ubo_stride = get_aligned(s->global_ubo_size, s->required_ubo_alignment);
    s->ubo_stride = get_aligned(s->ubo_size, s->required_ubo_alignment);

    // Uniform  buffer.
    // TODO: max count should be configurable, or perhaps long term support of buffer resizing.
    u64 total_buffer_size = s->global_ubo_stride + (s->ubo_stride * VULKAN_MAX_MATERIAL_COUNT);  // global + (locals)
    if (!renderer_renderbuffer_create(RENDERBUFFER_TYPE_UNIFORM, total_buffer_size, true, &uniform_buffer)) {
        KERROR("Vulkan buffer creation failed for object shader.");
        return false;
    }
    renderer_renderbuffer_bind(&uniform_buffer, 0);

    // Allocate space for the global UBO, whcih should occupy the _stride_ space, _not_ the actual size used.
    if (!renderer_renderbuffer_allocate(&uniform_buffer, s->global_ubo_stride, &s->global_ubo_offset)) {
        KERROR("Failed to allocate space for the uniform buffer!");
        return false;
    }

    // Map the entire buffer's memory.
    mapped_uniform_buffer_block = vulkan_buffer_map_memory(plugin, &uniform_buffer, 0, VK_WHOLE_SIZE);

    // Allocate global descriptor sets, one per frame. Global is always the first set.
    VkDescriptorSetLayout global_layouts[3] = {
        descriptor_set_layouts[DESC_SET_INDEX_GLOBAL],
        descriptor_set_layouts[DESC_SET_INDEX_GLOBAL],
        descriptor_set_layouts[DESC_SET_INDEX_GLOBAL]};

    VkDescriptorSetAllocateInfo alloc_info = {VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO};
    alloc_info.descriptorPool = descriptor_pool;
    alloc_info.descriptorSetCount = 3;
    alloc_info.pSetLayouts = global_layouts;
    VK_CHECK(vkAllocateDescriptorSets(context->device.logical_device, &alloc_info, global_descriptor_sets));

    return true;
}

#ifdef _DEBUG
#define SHADER_VERIFY_SHADER_ID(shader_id)                                         \
    if (shader_id == INVALID_ID || context->shaders[shader_id].id == INVALID_ID) { \
        return false;                                                              \
    }
#else
#define SHADER_VERIFY_SHADER_ID(shader_id)  // do nothing
#endif

b8 vulkan_renderer_shader_use(renderer_plugin* plugin, shader* shader) {
    vulkan_context* context = (vulkan_context*)plugin->internal_context;
    vulkan_shader* s = shader->internal_data;
    vulkan_pipeline_bind(&context->graphics_command_buffers[context->image_index], VK_PIPELINE_BIND_POINT_GRAPHICS, &s->pipeline);
    return true;
}

b8 vulkan_renderer_shader_bind_globals(renderer_plugin* plugin, shader* s) {
    if (!s) {
        return false;
    }

    // Global UBO is always at the beginning, but use this anyway.
    s->bound_ubo_offset = s->global_ubo_offset;
    return true;
}

b8 vulkan_renderer_shader_bind_instance(renderer_plugin* plugin, shader* s, u32 instance_id) {
    if (!s) {
        KERROR("vulkan_shader_bind_instance requires a valid pointer to a shader.");
        return false;
    }
    vulkan_shader* internal = s->internal_data;

    s->bound_instance_id = instance_id;
    vulkan_shader_instance_state* object_state = &internal->instance_states[instance_id];
    s->bound_ubo_offset = object_state->offset;
    return true;
}

b8 vulkan_renderer_shader_apply_globals(renderer_plugin* plugin, shader* s) {
    vulkan_context* context = (vulkan_context*)plugin->internal_context;
    u32 image_index = context->image_index;
    vulkan_shader* internal = s->internal_data;
    VkCommandBuffer command_buffer = context->graphics_command_buffers[image_index].handle;
    VkDescriptorSet global_descriptor = internal->global_descriptor_sets[image_index];

    // Apply UBO first
    VkDescriptorBufferInfo bufferInfo;
    bufferInfo.buffer = ((vulkan_buffer*)internal->uniform_buffer.internal_data)->handle;
    bufferInfo.offset = s->global_ubo_offset;
    bufferInfo.range = s->global_ubo_stride;

    // Update descriptor sets.
    VkWriteDescriptorSet ubo_write = {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};
    ubo_write.dstSet = internal->global_descriptor_sets[image_index];
    ubo_write.dstBinding = 0;
    ubo_write.dstArrayElement = 0;
    ubo_write.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    ubo_write.descriptorCount = 1;
    ubo_write.pBufferInfo = &bufferInfo;

    VkWriteDescriptorSet descriptor_writes[2];
    descriptor_writes[0] = ubo_write;

    u32 global_set_binding_count = internal->config.descriptor_sets[DESC_SET_INDEX_GLOBAL].binding_count;
    if (global_set_binding_count > 1) {
        // TODO: There are samplers to be written. Support this.
        global_set_binding_count = 1;
        KERROR("Global image samplers are not yet supported.");

        // VkWriteDescriptorSet sampler_write = {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};
        // descriptor_writes[1] = ...
    }

    vkUpdateDescriptorSets(context->device.logical_device, global_set_binding_count, descriptor_writes, 0, 0);

    // Bind the global descriptor set to be updated.
    vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, internal->pipeline.pipeline_layout, 0, 1, &global_descriptor, 0, 0);
    return true;
}

b8 vulkan_renderer_shader_apply_instance(renderer_plugin* plugin, shader* s, b8 needs_update) {
    vulkan_context* context = (vulkan_context*)plugin->internal_context;
    vulkan_shader* internal = s->internal_data;
    if (internal->instance_uniform_count < 1 && internal->instance_uniform_sampler_count < 1) {
        KERROR("This shader does not use instances.");
        return false;
    }
    u32 image_index = context->image_index;
    VkCommandBuffer command_buffer = context->graphics_command_buffers[image_index].handle;

    // Obtain instance data.
    vulkan_shader_instance_state* object_state = &internal->instance_states[s->bound_instance_id];
    VkDescriptorSet object_descriptor_set = object_state->descriptor_set_state.descriptor_sets[image_index];

    if (needs_update) {
        VkWriteDescriptorSet descriptor_writes[2];  // Always a max of 2 descriptor sets.
        kzero_memory(descriptor_writes, sizeof(VkWriteDescriptorSet) * 2);
        u32 descriptor_count = 0;
        u32 descriptor_index = 0;

        VkDescriptorBufferInfo buffer_info;

        // Descriptor 0 - Uniform buffer
        if (internal->instance_uniform_count > 0) {
            // Only do this if the descriptor has not yet been updated.
            u8* instance_ubo_generation = &(object_state->descriptor_set_state.descriptor_states[descriptor_index].generations[image_index]);
            // TODO: determine if update is required.
            if (*instance_ubo_generation == INVALID_ID_U8 /*|| *global_ubo_generation != material->generation*/) {
                buffer_info.buffer = ((vulkan_buffer*)internal->uniform_buffer.internal_data)->handle;
                buffer_info.offset = object_state->offset;
                buffer_info.range = s->ubo_stride;

                VkWriteDescriptorSet ubo_descriptor = {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};
                ubo_descriptor.dstSet = object_descriptor_set;
                ubo_descriptor.dstBinding = descriptor_index;
                ubo_descriptor.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
                ubo_descriptor.descriptorCount = 1;
                ubo_descriptor.pBufferInfo = &buffer_info;

                descriptor_writes[descriptor_count] = ubo_descriptor;
                descriptor_count++;

                // Update the frame generation. In this case it is only needed once since this is a buffer.
                *instance_ubo_generation = 1;  // material->generation; TODO: some generation from... somewhere
            }
            descriptor_index++;
        }

        // Iterate samplers.
        if (internal->instance_uniform_sampler_count > 0) {
            u8 sampler_binding_index = internal->config.descriptor_sets[DESC_SET_INDEX_INSTANCE].sampler_binding_index;
            u32 total_sampler_count = internal->config.descriptor_sets[DESC_SET_INDEX_INSTANCE].bindings[sampler_binding_index].descriptorCount;
            u32 update_sampler_count = 0;
            VkDescriptorImageInfo image_infos[VULKAN_SHADER_MAX_GLOBAL_TEXTURES];
            for (u32 i = 0; i < total_sampler_count; ++i) {
                // TODO: only update in the list if actually needing an update.
                texture_map* map = internal->instance_states[s->bound_instance_id].instance_texture_maps[i];
                texture* t = map->texture;

                // Ensure the texture is valid.
                if (t->generation == INVALID_ID) {
                    switch (map->use) {
                        case TEXTURE_USE_MAP_DIFFUSE:
                            t = texture_system_get_default_diffuse_texture();
                            break;
                        case TEXTURE_USE_MAP_SPECULAR:
                            t = texture_system_get_default_specular_texture();
                            break;
                        case TEXTURE_USE_MAP_NORMAL:
                            t = texture_system_get_default_normal_texture();
                            break;
                        default:
                            KWARN("Undefined texture use %d", map->use);
                            t = texture_system_get_default_texture();
                            break;
                    }
                }

                vulkan_image* image = (vulkan_image*)t->internal_data;
                image_infos[i].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
                image_infos[i].imageView = image->view;
                image_infos[i].sampler = (VkSampler)map->internal_data;

                // TODO: change up descriptor state to handle this properly.
                // Sync frame generation if not using a default texture.
                // if (t->generation != INVALID_ID) {
                //     *descriptor_generation = t->generation;
                //     *descriptor_id = t->id;
                // }

                update_sampler_count++;
            }

            VkWriteDescriptorSet sampler_descriptor = {VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET};
            sampler_descriptor.dstSet = object_descriptor_set;
            sampler_descriptor.dstBinding = descriptor_index;
            sampler_descriptor.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
            sampler_descriptor.descriptorCount = update_sampler_count;
            sampler_descriptor.pImageInfo = image_infos;

            descriptor_writes[descriptor_count] = sampler_descriptor;
            descriptor_count++;
        }

        if (descriptor_count > 0) {
            vkUpdateDescriptorSets(context->device.logical_device, descriptor_count, descriptor_writes, 0, 0);
        }
    }

    // Bind the descriptor set to be updated, or in case the shader changed.
    vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, internal->pipeline.pipeline_layout, 1, 1, &object_descriptor_set, 0, 0);
    return true;
}
